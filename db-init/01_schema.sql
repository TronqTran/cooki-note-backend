create table public.categories
(
    category_id bigint generated by default as identity
        primary key,
    created_at  timestamp(6) not null,
    description varchar(500),
    is_deleted  boolean      not null,
    name        varchar(100) not null
        constraint uk_category_name
            unique,
    updated_at  timestamp(6) not null
);

alter table public.categories
    owner to postgres;

create index idx_category_name
    on public.categories (name);

create index idx_category_created_at
    on public.categories (created_at);

create index idx_category_is_active
    on public.categories (is_active);

create index idx_category_is_deleted
    on public.categories (is_deleted);

create table public.ingredients
(
    ingredient_id bigint generated by default as identity
        primary key,
    created_at    timestamp(6) not null,
    name          varchar(100) not null
        constraint uk_ingredient_name
            unique,
    updated_at    timestamp(6) not null,
    search_vector tsvector
);

alter table public.ingredients
    owner to postgres;

create index idx_ingredient_name
    on public.ingredients (name);

create index idx_ingredient_created_at
    on public.ingredients (created_at);

create index idx_ingredients_search_vector
    on public.ingredients using gin (search_vector);

create table public.media
(
    media_id   bigint generated by default as identity
        primary key,
    created_at timestamp(6) not null,
    public_id  varchar(255) not null
        constraint uk_media_public_id
            unique,
    type       varchar(20)  not null
        constraint media_type_check
            check ((type)::text = ANY
                   ((ARRAY ['IMAGE'::character varying, 'VIDEO'::character varying, 'AUDIO'::character varying])::text[])),
    updated_at timestamp(6) not null,
    url        varchar(500) not null
);

alter table public.media
    owner to postgres;

create index idx_media_created_at
    on public.media (created_at);

create index idx_media_public_id
    on public.media (public_id);

create table public.users
(
    user_id       bigint generated by default as identity
        primary key,
    biography     varchar(500),
    created_at    timestamp(6) not null,
    date_of_birth date,
    email         varchar(100) not null
        constraint uk_user_email
            unique,
    first_name    varchar(50),
    gender        varchar(10)
        constraint users_gender_check
            check ((gender)::text = ANY
                   ((ARRAY ['MALE'::character varying, 'FEMALE'::character varying, 'OTHER'::character varying, 'UNDEFINED'::character varying])::text[])),
    last_name     varchar(50),
    password      varchar(255),
    provider      varchar(50),
    provider_id   varchar(100),
    role          varchar(20)  not null
        constraint users_role_check
            check ((role)::text = ANY
                   ((ARRAY ['USER'::character varying, 'ADMIN'::character varying, 'MANAGER'::character varying])::text[])),
    status        varchar(20)  not null
        constraint users_status_check
            check ((status)::text = ANY
                   ((ARRAY ['ACTIVE'::character varying, 'DEACTIVATED'::character varying, 'BANNED'::character varying])::text[])),
    updated_at    timestamp(6) not null,
    username      varchar(50)  not null
        constraint uk_user_username
            unique
);

alter table public.users
    owner to postgres;

create table public.follows
(
    created_at   timestamp(6) not null,
    follower_id  bigint       not null
        constraint fk_follower_id
            references public.users,
    following_id bigint       not null
        constraint fk_following_id
            references public.users,
    constraint uk_follower_following
        primary key (follower_id, following_id)
);

alter table public.follows
    owner to postgres;

create index idx_follower_id
    on public.follows (follower_id);

create index idx_following_id
    on public.follows (following_id);

create table public.notifications
(
    notification_id bigint generated by default as identity
        primary key,
    created_at      timestamp(6) not null,
    is_read         boolean      not null,
    message         varchar(255) not null,
    target_id       bigint,
    type            varchar(30)  not null
        constraint notifications_type_check
            check ((type)::text = ANY
                   ((ARRAY ['LIKE'::character varying, 'COMMENT'::character varying, 'FOLLOW'::character varying, 'SYSTEM'::character varying])::text[])),
    recipient_id    bigint       not null
        constraint fk_notification_recipient
            references public.users,
    sender_id       bigint
        constraint fk_notification_sender
            references public.users
);

alter table public.notifications
    owner to postgres;

create index idx_notification_recipient
    on public.notifications (recipient_id);

create index idx_notification_is_read
    on public.notifications (is_read);

create index idx_notification_created_at
    on public.notifications (created_at desc);

create table public.recipes
(
    recipe_id         bigint generated by default as identity
        primary key,
    cook_time_minutes integer      not null,
    created_at        timestamp(6) not null,
    description       varchar(500),
    difficulty        varchar(20)  not null
        constraint recipes_difficulty_check
            check ((difficulty)::text = ANY
                   ((ARRAY ['EASY'::character varying, 'MEDIUM'::character varying, 'HARD'::character varying, 'VERY_HARD'::character varying])::text[])),
    is_deleted        boolean      not null,
    is_public         boolean      not null,
    servings          integer      not null,
    title             varchar(150) not null,
    updated_at        timestamp(6) not null,
    views_count       bigint       not null,
    category_id       bigint
        constraint fk_recipe_category
            references public.categories,
    user_id           bigint       not null
        constraint fk_recipe_user
            references public.users,
    search_vector     tsvector
);

alter table public.recipes
    owner to postgres;

create table public.comments
(
    comment_id bigint generated by default as identity
        primary key,
    content    text         not null,
    created_at timestamp(6) not null,
    depth      integer      not null,
    is_deleted boolean      not null,
    updated_at timestamp(6) not null,
    parent_id  bigint
        constraint fk_comment_parent
            references public.comments,
    recipe_id  bigint       not null
        constraint fk_comment_recipe
            references public.recipes,
    user_id    bigint       not null
        constraint fk_comment_user
            references public.users
);

alter table public.comments
    owner to postgres;

create index idx_comment_recipe
    on public.comments (recipe_id);

create index idx_comment_user
    on public.comments (user_id);

create index idx_comment_parent
    on public.comments (parent_id);

create index idx_comment_recipe_created
    on public.comments (recipe_id, created_at);

create table public.meal_plans
(
    meal_plan_id bigint generated by default as identity
        primary key,
    created_at   timestamp(6) not null,
    is_deleted   boolean      not null,
    meal_date    date         not null,
    meal_type    varchar(20)  not null
        constraint meal_plans_meal_type_check
            check ((meal_type)::text = ANY
                   ((ARRAY ['BREAKFAST'::character varying, 'LUNCH'::character varying, 'DINNER'::character varying, 'SNACK'::character varying])::text[])),
    note         text,
    updated_at   timestamp(6) not null,
    recipe_id    bigint       not null
        constraint fk_meal_plan_recipe
            references public.recipes,
    user_id      bigint       not null
        constraint fk_meal_plan_user
            references public.users,
    constraint uk_meal_plan_user_date_meal_recipe
        unique (user_id, meal_date, meal_type, recipe_id)
);

alter table public.meal_plans
    owner to postgres;

create index idx_meal_plan_user_date
    on public.meal_plans (user_id, meal_date);

create index idx_meal_plan_recipe
    on public.meal_plans (recipe_id);

create index idx_meal_plan_user_active
    on public.meal_plans (user_id, is_deleted);

create table public.recipe_ingredients
(
    created_at    timestamp(6)   not null,
    note          varchar(500),
    quantity      numeric(10, 2) not null,
    required      boolean        not null,
    unit          varchar(50),
    updated_at    timestamp(6)   not null,
    ingredient_id bigint         not null
        constraint fk_recipe_ingredient_ingredient
            references public.ingredients,
    recipe_id     bigint         not null
        constraint fk_recipe_ingredient_recipe
            references public.recipes,
    primary key (ingredient_id, recipe_id)
);

alter table public.recipe_ingredients
    owner to postgres;

create index idx_recipe_ingredient_recipe
    on public.recipe_ingredients (recipe_id);

create index idx_recipe_ingredient_ingredient
    on public.recipe_ingredients (ingredient_id);

create table public.recipe_likes
(
    created_at timestamp(6) not null,
    updated_at timestamp(6) not null,
    recipe_id  bigint       not null
        constraint fk_like_recipe
            references public.recipes,
    user_id    bigint       not null
        constraint fk_like_user
            references public.users,
    constraint uk_user_recipe_like
        primary key (recipe_id, user_id)
);

alter table public.recipe_likes
    owner to postgres;

create index idx_like_recipe
    on public.recipe_likes (recipe_id);

create index idx_like_user
    on public.recipe_likes (user_id);

create index idx_like_recipe_created
    on public.recipe_likes (recipe_id, created_at);

create table public.recipe_media
(
    created_at timestamp(6) not null,
    type       varchar(50)  not null
        constraint recipe_media_type_check
            check ((type)::text = ANY
                   ((ARRAY ['AVATAR'::character varying, 'COVER'::character varying, 'BACKGROUND'::character varying, 'BANNER'::character varying, 'GALLERY'::character varying, 'THUMBNAIL'::character varying, 'LOGO'::character varying])::text[])),
    updated_at timestamp(6) not null,
    media_id   bigint       not null
        constraint fk_recipe_media_media
            references public.media,
    recipe_id  bigint       not null
        constraint fk_recipe_media_recipe
            references public.recipes,
    primary key (media_id, recipe_id)
);

alter table public.recipe_media
    owner to postgres;

create index idx_recipe_media_recipe_id
    on public.recipe_media (recipe_id);

create index idx_recipe_media_media_id
    on public.recipe_media (media_id);

create index idx_recipe_user
    on public.recipes (user_id);

create index idx_recipe_category
    on public.recipes (category_id);

create index idx_recipe_visibility
    on public.recipes (is_public);

create index idx_recipe_created_at
    on public.recipes (created_at);

create index idx_recipe_public_created
    on public.recipes (is_public, created_at);

create index idx_recipes_search_vector
    on public.recipes using gin (search_vector);

create table public.shopping_lists
(
    shopping_list_id bigint generated by default as identity
        primary key,
    created_at       timestamp(6) not null,
    is_deleted       boolean      not null,
    note             varchar(500),
    planned_date     date,
    status           varchar(20)  not null
        constraint shopping_lists_status_check
            check ((status)::text = ANY
                   ((ARRAY ['ACTIVE'::character varying, 'FINISHED'::character varying, 'CANCELLED'::character varying])::text[])),
    title            varchar(200) not null,
    updated_at       timestamp(6) not null,
    user_id          bigint       not null
        constraint fk_shopping_list_user
            references public.users
);

alter table public.shopping_lists
    owner to postgres;

create table public.shopping_items
(
    purchased        boolean        not null,
    quantity         numeric(38, 2) not null,
    unit             varchar(50),
    ingredient_id    bigint         not null
        constraint fk_item_ingredient
            references public.ingredients,
    shopping_list_id bigint         not null
        constraint fk_item_shopping_list
            references public.shopping_lists,
    constraint uk_item_shopping_list_ingredient
        primary key (ingredient_id, shopping_list_id)
);

alter table public.shopping_items
    owner to postgres;

create index idx_shopping_item_shopping_list
    on public.shopping_items (shopping_list_id);

create index idx_shopping_item_ingredient
    on public.shopping_items (ingredient_id);

create index idx_shopping_list_user
    on public.shopping_lists (user_id);

create index idx_shopping_list_date
    on public.shopping_lists (planned_date);

create index idx_shopping_list_user_status
    on public.shopping_lists (user_id, status);

create table public.steps
(
    step_id     bigint generated by default as identity
        primary key,
    created_at  timestamp(6)  not null,
    description varchar(1000) not null,
    is_deleted  boolean       not null,
    step_order  integer       not null,
    updated_at  timestamp(6)  not null,
    recipe_id   bigint        not null
        constraint fk_step_recipe
            references public.recipes
);

alter table public.steps
    owner to postgres;

create table public.step_media
(
    created_at timestamp(6) not null,
    updated_at timestamp(6) not null,
    media_id   bigint       not null
        constraint fk_step_media_media
            references public.media,
    step_id    bigint       not null
        constraint fk_step_media_step
            references public.steps,
    primary key (media_id, step_id)
);

alter table public.step_media
    owner to postgres;

create index idx_step_recipe_order
    on public.steps (recipe_id, step_order);

create table public.user_media
(
    created_at timestamp(6) not null,
    type       varchar(50)  not null
        constraint user_media_type_check
            check ((type)::text = ANY
                   ((ARRAY ['AVATAR'::character varying, 'COVER'::character varying, 'BACKGROUND'::character varying, 'BANNER'::character varying, 'GALLERY'::character varying, 'THUMBNAIL'::character varying, 'LOGO'::character varying])::text[])),
    updated_at timestamp(6) not null,
    media_id   bigint       not null
        constraint fk_user_media_media
            references public.media,
    user_id    bigint       not null
        constraint fk_user_media_user
            references public.users,
    primary key (media_id, user_id)
);

alter table public.user_media
    owner to postgres;

create index idx_user_email
    on public.users (email);

create index idx_user_username
    on public.users (username);

create index idx_user_status
    on public.users (status);

